#!/usr/bin/env python3
"""
Kaprekar Text Encoder / Decoder
================================
A lossless text encoding system using:
1. UTF-8 text → binary → 4-bit nibbles → 4-digit numbers (1000 + val*100)
2. Kaprekar's routine on each 4-digit number → converges to 6174 or 0
3. Reverse mapping to recover original text

Author: @cigboo (with Grok)
Date: November 15, 2025
"""

import json
import time
import os
from typing import List, Dict, Tuple, Any


# ==============================================================
# MODULE 1: TEXT <-> BINARY <-> NIBBLE <-> 4-DIGIT CONVERSION
# ==============================================================

class TextCodec:
    """Handles conversion between text, binary, nibbles, and 4-digit numbers."""

    @staticmethod
    def text_to_nibbles(text: str) -> List[str]:
        """
        Convert UTF-8 text to list of 4-bit binary strings (nibbles).
        Example: 'A' → '01000001' → ['0100', '0001']
        """
        bytes_data = text.encode('utf-8')
        bits = ''.join(f'{byte:08b}' for byte in bytes_data)
        return [bits[i:i+4] for i in range(0, len(bits), 4)]

    @staticmethod
    def nibble_to_4digit(nibble: str) -> int:
        """Convert 4-bit nibble to unique 4-digit number: 1000 + value * 100"""
        value = int(nibble, 2)
        return 1000 + value * 100

    @staticmethod
    def four_digit_to_nibble(digit4: int) -> str:
        """Reverse: 4-digit → 4-bit nibble"""
        value = (digit4 - 1000) // 100
        return f'{value:04b}'

    @staticmethod
    def four_digits_to_text(four_digits: List[int]) -> str:
        """Reconstruct original text from list of 4-digit numbers"""
        nibbles = [TextCodec.four_digit_to_nibble(d) for d in four_digits]
        # Group into 8-bit bytes
        bytes_list = []
        for i in range(0, len(nibbles), 2):
            byte_str = nibbles[i] + (nibbles[i+1] if i+1 < len(nibbles) else '0000')
            bytes_list.append(int(byte_str, 2))
        return bytes(bytes_list).decode('utf-8', errors='ignore')


# ==============================================================
# MODULE 2: KAPREKAR ROUTINE
# ==============================================================

class Kaprekar:
    """Performs Kaprekar's routine on 4-digit numbers."""

    @staticmethod
    def step(num: int) -> int:
        """
        One Kaprekar step: largest - smallest digit arrangement.
        Example: 1234 → 4321 - 1234 = 3087
        """
        s = ''.join(sorted(str(num).zfill(4)))
        l = s[::-1]
        return int(l) - int(s)

    @staticmethod
    def compute_path(start: int) -> Dict[str, Any]:
        """
        Compute full Kaprekar path until 6174 or 0.
        Returns: {steps, path, final}
        """
        if start == 0:
            return {"steps": 0, "path": [0], "final": 0}

        seen = set()
        current = start
        path = [current]
        steps = 0

        while current not in (6174, 0) and current not in seen:
            seen.add(current)
            current = Kaprekar.step(current)
            path.append(current)
            steps += 1

        return {"steps": steps, "path": path, "final": current}


# ==============================================================
# MODULE 3: SESSION & FILE I/O
# ==============================================================

class Session:
    """Manages encoding session state and persistence."""

    def __init__(self):
        self.original: str = ""
        self.four_digits: List[int] = []
        self.kaprekar: List[Dict] = []

    def encode(self, text: str) -> None:
        """Encode text → 4-digit → Kaprekar"""
        self.original = text
        nibbles = TextCodec.text_to_nibbles(text)
        self.four_digits = [TextCodec.nibble_to_4digit(n) for n in nibbles]
        self.kaprekar = [Kaprekar.compute_path(d) for d in self.four_digits]

    def decode(self) -> str:
        """Decode back to original text"""
        return TextCodec.four_digits_to_text(self.four_digits)

    def save(self, filepath: str) -> None:
        """Save session to JSON"""
        data = {
            "original": self.original,
            "four_digits": self.four_digits,
            "kaprekar": self.kaprekar
        }
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2)
        print(f"Session saved to: {filepath}")

    def load(self, filepath: str) -> None:
        """Load session from JSON"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        self.original = data["original"]
        self.four_digits = data["four_digits"]
        self.kaprekar = data["kaprekar"]
        print(f"Session loaded from: {filepath}")


# ==============================================================
# MODULE 4: MAIN UTILITY & CLI
# ==============================================================

def benchmark_encode_decode(text: str) -> Tuple[float, float]:
    """Time encode + decode round-trip"""
    session = Session()

    # Encode
    start = time.perf_counter()
    session.encode(text)
    encode_time = (time.perf_counter() - start) * 1000  # ms

    # Decode
    start = time.perf_counter()
    decoded = session.decode()
    decode_time = (time.perf_counter() - start) * 1000  # ms

    assert decoded == text, "LOSSY ENCODING! Decode failed."
    return encode_time, decode_time


def main():
    """Interactive CLI demo"""
    print("Kaprekar Text Encoder / Decoder")
    print("=" * 50)

    while True:
        print("\nOptions:")
        print("1. Encode text")
        print("2. Load & decode JSON")
        print("3. Benchmark")
        print("4. Exit")
        choice = input("\nChoose (1-4): ").strip()

        if choice == '1':
            text = input("\nEnter your message:\n> ")
            session = Session()
            session.encode(text)

            # Stats
            count_6174 = sum(1 for k in session.kaprekar if k["final"] == 6174)
            count_0 = len(session.kaprekar) - count_6174
            print(f"\nEncoded! {len(session.four_digits)} numbers")
            print(f"→ 6174 × {count_6174} | 0000 × {count_0}")

            save = input("Save session? (y/n): ").lower() == 'y'
            if save:
                filepath = f"kaprekar_session_{int(time.time())}.json"
                session.save(filepath)

        elif choice == '2':
            filepath = input("Enter JSON file path: ").strip()
            if os.path.exists(filepath):
                session = Session()
                session.load(filepath)
                print(f"Decoded text:\n{session.decode()}")
            else:
                print("File not found.")

        elif choice == '3':
            text = input("Enter text to benchmark: ")
            e_time, d_time = benchmark_encode_decode(text)
            print(f"Encode: {e_time:.3f} ms | Decode: {d_time:.3f} ms | Total: {e_time + d_time:.3f} ms")

        elif choice == '4':
            print("Goodbye, @cigboo!")
            break

        else:
            print("Invalid choice.")


# ==============================================================
# ENTRY POINT
# ==============================================================

if __name__ == "__main__":
    # Run CLI
    main()

